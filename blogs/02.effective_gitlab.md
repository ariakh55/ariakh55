<doc-info draft="true">
<doc-title>How to effectivly manage releases with gitlab</doc-title>
<doc-description>
The best way to manage team in GitLab and avoid unnecessary complexity
</doc-description>
<doc-author>Aria Kh.</doc-author>
<doc-published>April 28, 2025</doc-published>
</doc-info>

# How to effectively manage releases with GitLab

## Intro
Software development is an accumulation of Thinking, Setup, Developing, Improvement, Testing, and the most important part Delivering.
Why delivering is important, might some ask? Because it can affect the whole process and without a good delivery even for a software which is going to be used
by the developer will result in a total disaster and failure.

From experience and working on multiple projects (many unfinished over weekend side-projects) I came to this understanding
that managing the releases and the strategy to do so can be a tedious work and sometimes it will lead to 
huge complexities.

In order to fix this issue I wanted to share my own strategy to avoid these kind of complexities for any type of projects 
(mostly the ones with teams scaling from more than 3 developers).

<div style="margin: 0 auto;max-width: fit-content">
<img src="https://b1286009.smushcdn.com/1286009/wp-content/uploads/2020/04/a-world-without-ci.cd-meme.jpg?&webp=1" alt="CI?"/>
</div>

## The Issue
The issue or better said the type of issues. After this section it will be explained in details. There are multiple types of deploying
your application and delivering it to your customer. One is can be said the traditional manual build and uploading it in fileserver ready to be downloaded.
But sometimes your team is too cutting edge and modern to do so. Instead the higher-ups hire a DevOps guy and a developer to write Dockerfile/docker-compose files
to automate the build and release using either GitHub Actions, GitLab CI or many other CI/CD out there.

But unfortunately having a CI/CD is not the solution and this might lead to a bigger disaster called branching hell.
The project I was working on last month has this issue and for each deployment environment there is a branch with that name which has a set of gitlab-ci.yml rules.

On the surface it looks ok everything might be OK! but no. a BIG **<span style="color: red;">NO</span>**.

You might ask why? Let me tell you. You set a rule on your dev team to squash every MR's commits to have clean timeline,
only then to create MRs to deploy to each env (without squashing cause you don't want to lose the timeline on staging and production).

It seems ok! Yeah kinda. Wait till you want to deploy a hotfix or suddenly PMs wants an emergency change for demo meeting.
That's where all the things going to tear apart.
First checkout from staging (cause no direct MR to prod) then work on branch, make MR, MR gets "Approved", MR is merged to staging and Staging gets deployed to prod after QA
and all the tests running and making sure nothing is broken. Crisis averted. You go back to your feature/bug branch which is checked out from master (nightly) and you work peacefully on that.

_FastForward_: A week later sprint is over the new version is going to be deployed on staging. BOOM the hotfix is gone. Oh no somebody forgot to cherry-pick and merge-back that hotfix.
OR FAR WORSE, you merged it back to master but now there is big conflict that needs to be resolved and everybody is blocked.
Even worse the bug that was hotfixed a week ago is now regressed and is back in production.

That's why I say it's not a good idea, no matter how much time and rules you as the tech lead set to make sure everything works perfect.
Ergo, be kind to yourself and don't do it.

## The Solution
It might sound simple but looking at other repositories in GitHub for example <a href="https://github.com/neovim/neovim" rel="noref" target="_blank">NEOVIM<span class="icon"></span></a>. They have Tag and Release system which is well integrated
into git.

Tags are like branches but different in a way. They are annotated to be used in deploying and versioning, so that the branches can be used solely for development. Also cloud providers
give the option of creating a release from these Tags which makes it way more easy and simple to build/deploy and deliver without worrying about the merge conflicts and 
changes being overridden.

But how to switch from our branch hell or start using this on our new projects? I am no expert and I just chatted with gippity made feel guilty and stoopid for giving the thing I already knew.
but I will try to include my experience to help implement this flow in projects.

Note that I'll be using gitlab for this example but it's all about the concept. Once acquired can be applied to anywhere else.

## The flow (concept or whatever)
First we need to clean our project. Delete all the extra branches, have no mercy cause you are about to "clean-up".
After the clean up you should only have a master/main branch. Make sure that branch is protected and all in the remote repo.

Then set a versioning strategy. <a href="https://semver.org/" ref="noref" target="_blank">Semver<span class="icon"></span></a> one generic all purpose versioning which can be used and
understood easily.

You are all set now for the flow to be described.

### Branching Strategy
In this flow we use a main branch called (master/main) to deploy the next/nightly version. Developers create their branches
from this branch either it is a feature or a bugfix/hotfix branch.
Each dev branch has a CI/CD pipeline for integration tests, lint, even build/deploy to dev envs or dev binaries.

*Every test will be done in these branches to make sure nothing will break/regress* 

Also devs who are working together or have parallel tasks can agree on a single dev branch to aggregate and accumulate their changes for final deploy to master.

### Versioning and Tags
After finalizing the changes on dev branches and the approval of the PMs and Reviewers changes the MR can be merged (with a proper naming) to master/main to be built as nightly.
Nightly builds in the scenario can be considered as a Release Candidate to be versioned for staging and production envs.

*In some cases master branches are built/deployed automatically, so in this case tagging and versioning will be a matter of preference* 

After successful build/deploy to next/nightly env the release manager can begin to mark the changes from nightly to Tag with proper version to staging or (directly to production).
For example a tag can be created as following:

```bash
# staging env/build
git tag v1.0.0-staging

# production
git tag v1.0.0
```

Then pushing the tag like a normal branch to the remote repo. The tag is created and pushed.

Also it is a matter of preference to automate the process of making release and/or deploying it to a server/k8s cluster or keeping it manual.


### Releases
As mentioned in the previous section, Releases can be created from Tags and be built/deployed. A good thing about
releases is the ability to easily rollback and revert the changes. Also in case of needing a hotfix or a sudden change 
the same flow can be used from dev all the way to production without the concern of missing or conflicts in the branches which will be explained in the next section.

### Hotfixes
In this flow as mentioned hotfixes will also have the same base as the master/main branch and the application of
the hotfix is a simple interactive rebase or a cherry-pick to the hotfix tag named for example `v1.0.1-staging`.


